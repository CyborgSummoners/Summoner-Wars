// Generated by Bisonc++ V2.4.8 on Tue, 18 Sep 2012 16:33:31 +0200
// then heavily modified. DO NOT try to delete and regen.

#ifndef Parser_h_included
#define Parser_h_included

#include "../bytecode.hpp"
#include "summparsebase.h"
#include "compiler.hpp"
#include <map>
#include <stdint.h>


#undef Parser

class yyFlexLexer;

class Parser: public ParserBase {
	// more or less temporary:
	public:
		enum action {FULL=0, ASSEMBLED, BYTECODE, NOINPUT, FILE_ERROR, MALFORMED_ARGS};
	private:
		action act;


	private:
		yyFlexLexer* lexer;

	public:
		std::vector<bytecode::subprogram> subprograms;	// list of parsed subprograms
		std::map<std::string, var> symtab;	// symbol table of variables

	public:
		Parser(yyFlexLexer* lexer, action act=FULL) : act(act), lexer(lexer){}

    public:
        int parse();	// starts the parsing

		static void second_pass(std::vector<codeline>& code);	// cleanup & optimize code a bit.
		static void assemble(std::vector<codeline>& code, byte*& Result, size_t& length);	// assemble code into actual bytecode.

    private:
        void error(char const *msg);    // called on (syntax) errors
        void warning(char const *msg);
        int lex();                      // returns the next token from the lexical scanner.
		void print();                   // use, e.g., d_token, d_loc

		// support functions for parse():
		void executeAction(int ruleNr);
		void errorRecovery();
		int lookup(bool recovery);
		void nextToken();

		//utility
		uint32_t gen_label();
		uint32_t get_value(const std::string& str);
};

inline void Parser::error(char const *msg) {
	std::cerr << d_loc__.first_line << ": " << msg;
}

inline void Parser::warning(char const *msg) {
	std::cerr << d_loc__.first_line << ": " << msg;
}

inline void Parser::print() {
}


#endif
